- #leetcode #滑动窗口
- 给定一个二进制数组 `nums` 和一个整数 `k`，假设最多可以翻转 `k` 个 `0` ，则返回执行操作后 *数组中连续 `1` 的最大个数* 。
-
- **示例 1：**
- ```
  **输入：**nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
  **输出：**6
  **解释：**[1,1,1,0,0,**1**,1,1,1,1,**1**]
  粗体数字从 0 翻转到 1，最长的子数组长度为 6。
  ```
- **示例 2：**
- ```
  **输入：**nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
  **输出：**10
  **解释：**[0,0,1,1,**1**,**1**,1,1,1,**1**,1,1,0,0,0,1,1,1,1]
  粗体数字从 0 翻转到 1，最长的子数组长度为 10。
  ```
-
- 解题思路:
	- 主题为滑动窗口,盲猜是维护一个当前最长的连续1的长度和还能翻转的个数,窗口往右移动,判断是否为1,若为1则窗口左边不动,右边继续移动,若不为1,再判断余额能不能继续翻转,若能继续翻转,则消耗一个余额,窗口右边继续移动,如果不能继续翻转,则窗口整体往右移动,若移除的数为1则继续移动直到移除的数为0,
-
	- 这个思路还是太复杂了,不需要重复统计窗口内0的个数,可以转为为已统计的0的个数和被移出窗口的0个数
- ```
  class Solution {
  public:
      int longestOnes(vector<int>& nums, int k) {
          int n = nums.size();
          int left = 0, lsum = 0, rsum = 0;
          int ans = 0;
          for (int right = 0; right < n; ++right) {
              rsum += 1 - nums[right];//统计窗口内有多少个零
              while (lsum < rsum - k) {//当已统计的零比能翻转的零与被移出窗口的零之和要多的时候开始循环,目标:要保持能翻转的零与被移出窗口的零之和大于等于已统计的零
                  lsum += 1 - nums[left];//窗口左边开始移动,统计被移除窗口的0的个数
                  ++left;
              }
              ans = max(ans, right - left + 1);
          }
          return ans;
      }
  };
  
  ```